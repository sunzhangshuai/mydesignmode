# 重构

> 重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。

## 目的「Why」
> - 重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。
> - 是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。

## 对象「Who」
- **大规模重构**
    
    > - 重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。
    > - 利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。
    
- **小规模重构**
    
    > - 重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题。
    > - 主要是针对类、函数级别的重构。

## 时机「When」
> 建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中。

## 方法「How」
- **大规模重构**

  > 需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。

- **小规模重构**

  > 只要你愿意并且有时间，随时随地都可以去做。

# 代码优化

## 代码的可测试性

> 针对代码编写单元测试的难易程度。

- **可测试性手段**

  > 依赖注入

- **反例**

  > - 代码中包含未决行为逻辑。（随机）将未决行为重新封装，测试时mock，使用匿名类。
  > - 滥用可变全局变量
  > - 滥用静态方法
  > - 使用复杂的继承关系
  > - 高度耦合的代码

## 解耦

- **重要性**

  > - 控制代码复杂度。
  > - 代码结构清晰、分层模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。

- **判断是否需要解耦**

  > - 修改代码是否牵一发动全身。
  > - 把模块与模块、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断。

- **解耦方法**

  > - 封装与抽象、中间层、模块化。
  > - 设计思想和原则：
  >     - 单一职能原则
  >     - 基于接口而非实现编程
  >     - 依赖反转原则
  >     - 多用组合少用继承
  >     - 迪米特法则
  > - 设计模式
  >     - 观察者模式

## 编码规范

### 命名和注释

1. 命名
    - 命名不要暴露过多细节。
    - 命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。
    - 利用上下文简化命名。
        - 函数通过类名简化命名。
        - 变量名借助函数名简化命名。
    - 命名要可读、可搜索。
        - 可读：不要用一些特别生僻、难发音的英文单词来命名。
        - 可搜索：最好能符合整个项目的命名习惯。
    - 统一接口或抽象类的前缀
1. 注释
    - 注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。
    - 类和函数一定要写注释，而且要写得尽可能全面、详细。
    - 函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

### 代码风格

1. **类和函数代码行数**
    
    - *函数*：代码行数不要超过一屏幕的大小，比如 50 行。
    - *类*：读起来感觉头大，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了。
    
2. **一行代码长度**
    
    > 一行代码最长不能超过 IDE 显示的宽度。
    
3. **善用空行分割单元块**

4. **缩进风格统一**
    
    - PHP倾向于四格缩进
    - JAVA倾向于两格缩进
    
5. **大括号是否要另起一行**
    
    - PHP方法换行，if不换行
    - JAVA倾向于不换行
    
6. **类中成员的排列顺序**
    
    - 先写类所属的包名，然后再罗列引入的依赖类。
    - 成员变量排在函数的前面。
    - 先静态、后普通。
    - 作用域范围从大到小的顺序来排列。public、protected、private。

### 编码技巧

1. **把代码分割成更小的单元块**
   
    > 只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。
    
2. **避免函数参数过多**

    > 1. 大于等于 5 个的时候，我们就觉得参数有点过多了。
    > 2. 考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。
    > 3. 将函数的参数封装成对象。
    
3. **勿用函数参数来控制逻辑**

4. **函数设计要职责单一**

5. **移除过深的嵌套层次**

    > 嵌套最好不超过两层。
    > 1. 去掉多余的 if 或 else 语句。
    > 2. 使用编程语言提供的 continue、break、return 关键字，提前退出嵌套。
    > 3. 调整执行顺序来减少嵌套。
    > 4. 将部分嵌套逻辑封装成函数调用，以此来减少嵌套。
    > 5. 使用多态来替代 if-else、switch-case 条件判断。
    
6. **使用解释性变量**

    > 1. 常量取代魔法数字。
    > 2. 使用解释性变量来解释复杂表达式。

## 代码质量问题

- **常规**

  - 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？

  - 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？

  - 设计模式是否应用得当？是否有过度设计？

  - 代码是否容易扩展？如果要添加新功能，是否容易实现？

  - 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？

  - 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？

  - 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？


- **业务需求**

  - 代码是否实现了预期的业务需求？

  - 逻辑是否正确？是否处理了各种异常情况？

  - 日志打印是否得当？是否方便 debug 排查问题？

  - 接口是否易用？是否支持幂等、事务等？

  - 代码是否存在并发问题？是否线程安全？

  - 性能是否有优化空间，比如，SQL、算法是否可以优化？

  - 是否有安全漏洞？比如输入输出校验是否全面？

## 代码异常

- **受检异常**

    > 受检异常需要显式地在函数定义中声明。
- **非受检异常**

    > 我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。

## 单元测试

> 单元测试的对象是类或者函数。
> 单元测试是由程序员自行编写，用于测试代码正确性。

- **为什么要写单元测试**

  > 编写单元测试是code review的过程。
  > 还是对集成测试的有力补充。

- **如何编写单元测试**

  > - 覆盖各种输入、异常、边界情况。
  >
  > - 编写单元测试尽管繁琐，但并不是太耗时。
  > - 我们可以稍微放低对单元测试代码质量的要求。
  > - 覆盖率作为衡量单元测试质量的唯一标准是不合理的。
  > - 单元测试不要依赖被测代码的具体实现逻辑。
  > - 单元测试框架无法测试，多半是因为代码的可测试性不好。

- **单元测试为何难落地执行**

  > 写单元测试本身比较繁琐，技术挑战不大。

# 面相对象

## 四大特性

- **封装**

  > - 数据隐藏或数据访问保护。
  > - 提供有限的方法访问内部信息和数据。
  > - 语言要实现访问控制语法。
  >
  > 个人理解：简单一句话就是。在一个类内部设定了不同的属性和方法的访问权限，只能让公共特性的内容完全对外访问，这个类的内部信息就被封装了。

  - *意义*

    > 保护类内部的属性不被随意修改。提升代码的维护成本。

  - *解决的问题*

    > 一句话：让专业的人做专业的事。

- **继承**

  > 设定从属关系，即大范围、小范围。

  - *意义*

    > 通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知。

  - *解决的问题*

    > 代码复用

- **抽象**

  > - 对于不同的事物，在一定的角度分析出他们的公共属性和公共的行为，对这些东西进行抽离定义。抽象类是从类的角度。
  > - 甚至于一个包裹具体逻辑的方法，本身就是抽象。因为他可以本不同的事务调用，只要该事物需要。
  > - 定义底层方法是要具有抽象思维，不要命名过于具体。

  - *意义*

    > 人脑承载的信息有限，有助于在分析复杂问题是，用更多的精力去关注功能点，忽略细节。

  - *解决的问题*

    > 指导代码开发，以此来实现各种设计模式。具化设计原则。

- **多态**

  > - 定义
  >
  >   子类可以替代父类。
  >
  >   - 父类中要支持引用子类对象。
  >   - 子类要可以继承父类。
  >   - 子类可用重写父类方法。
  >

  - *意义*

    > 提高代码的复用性和可扩展性。

  - *解决的问题*

    > 设计模式、设计原则、编程技巧的代码实现基础。

## 面向对象和面向过程

- **面向对象**

  - *面向对象语言*

    > 支持类和对象的语法机制的语言

  - *面向对象编程*

    > - 名词：讲一种编程范式和风格
    > - 动词：编程过程中，以类和对象作为最小单元进程编程。

  - *面向对象分析*

    > 搞清楚要做什么。自底向上的思维方式
    >

  - *面向对象设计*

    > 搞清楚怎么做

  - *优势*

    1. 对于大规模的开发，非线性的网状结构，面向对象更方便。
    2. 拥有更丰富的特性，用这些特性可以开发出更加易扩展、易复用、易维护的代码。
    3. 更加人性化、更加高级、更加智能。

- **面向过程**

  - *面向过程编程*

    > 组合一系列的方法和数据结构，方法定义和数据结构本身是分开的。
    >
    > 而对于面向过程来说，强关联关系（相同类型）的方法和数据结构整合到一个类中。被拆成了很多组。

  - *面向过程语言*

    > 不支持类和对象的语言。

  - *看似是面向对象，实际是面向过程*

    - 滥用getter和setter方法，违反了封装特性。即所有的属性均定义为公共属性。

      > 会影响有强关联关系属性的数据一致性。

    - 滥用全局变量和全局方法。不要让全局类过于大而全。

      > 利用继承原则尽量拆解分组。
      >
      > 把全局属性方法用到的类中.

    - 定义数据和方法分离的类。

      > 基于贫血模型的开发模式（MVC）

## 接口和抽象类
- **区别**

  - *抽象类*

    > - 不允许被实例化，只能继承。
    > - 包括属性和方法（普通方法和抽象方法）。
    > - 抽象方法必须被重写。

  - *接口*

    > - 不能定义属性。
    > - 包含方法，但是不能实现。
    > - 实现接口必须实现接口内的所有方法。


- **意义**

  > 为了抽象。

- **解决的问题**

  > - 抽象类为实现代码复用，抽象类规定必须实现的方法指定起来更为优雅。
  > - 接口侧重于解耦。

- **应用场景**

  > 为解决复用性：使用抽象类
  > 为解决抽象：使用接口

- **基于接口而非实现编程**

  > 封装不稳定的实现，提供稳定的接口。当实现变更时，或者被继承者变更时，调用者不需要做改变。因为调用者使用的是稳定的接口。针对接口编程而不是实现编程，就是让协议和契约的信任程度来到最高。

  1. 函数命名不暴露实现细节。公共细节由类名定义，方法不要写类的细节。
  2. 封装具体的实现细节。
  3. 为实现类定义抽象的接口。

## 组合和继承
> 组合优于继承，多用组合少用继承。

- **继承缺陷**

  > 可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。

- **组合的优势**

  > 支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。

- **使用组合还是继承**

  > 如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。

## 贫血模型和充血模型
> **贫血模型**：从业务为出发点，填什么需求就加什么取数据的方式。
>
> **充血模型(DDD)**：是在数据模型搭建时，想清楚可以暴露出的接口，增加代码的复用性。

## 类与类的关系

- 泛化

  > 继承关系

  ```java
  public class A { ... }
  public class B extends A { ... }
  ```

- **实现**

  > 接口和实现类之间的关系

  ```java
  public interface A {...}
  public class B implements A { ... }
  ```

- **聚合**

  > A 类对象包含 B 类对象
  > B 类对象的生命周期可以不依赖 A 类对象的生命周期

  ```java
  public class A {
      private B b; 
      public A(B b) { 
          this.b = b; 
      }
  }
  ```

- **组合**

  > A 类对象包含 B 类对象，
  > B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在

  ```java
  public class A {
      private B b; 
      public A() { 
          this.b = new B();
      }
  }
  ```

- **关联**

  > 包含聚合、组合两种关系。

- **依赖**

  > 不管是 B 类对象是 A 类对象的成员变量。
  > 还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量。
  > 只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。

## MVC

> 1. 分层能起到代码复用的作用。
> 2. 分层能起到隔离变化的作用。
> 3. 分层能起到隔离关注点的作用。
> 4. 分层能提高代码的可测试性。
> 5. 分层能应对系统的复杂性。

# 设计原则

## 单一职责原则「S」

> - 一个类只负责完成一个职责或者功能。
> - 不要设计大而全的类，要设计粒度小、功能单一的类。

- **目的**

  > 实现代码的高内聚、低耦合，提高代码的复用性、可读性、可维护性。

- **实现**

  > 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。

- **判断原则**

  > 1. 类中的代码行数、函数或者属性过多。
  > 2. 类依赖的其他类过多，或者依赖类的其他类过多。
  > 3. 私有方法过多。
  > 4. 比较难给类起一个合适的名字。
  > 5. 类中大量的方法都是集中操作类中的某几个属性。

## 开闭原则「O」
> 扩展性会牺牲一部分可读性。
>
> 对扩展开放、对修改关闭。
>
> 向现有系统添加功能时，应该在已有的代码基础上扩展代码，而不是修改原来的代码。

- **目的**

  > - 不破坏原有代码的正常运行，不破坏原有的单元测试。
  > - 尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。

## 里氏替换原则「L」

> - 子类对象能够替换程序中父类对象出现的任何地方，并保证原来程序的逻辑行为不变及正确性不被破坏。
> - 按照协议来设计。子类在设计时，要遵循父类的行为约定。
>
>   1. 函数声明要实现的功能；对输入、输出、异常的约定。
>   2. 包括注释中所罗列的任何特殊说明。
>   3. 定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。
>

- **里氏替换和多态**

    - *多态*：讲的是从语言实现的角度可以让子类完全替代父类。强调替换后可以通过编译。

    - *里氏替换*：强调的是替换后，当前代码在生产环境运行过程中不可以抛出未定义好的错误，影响原来逻辑的正确性。


- **违背里氏替换的情况**

  1. 子类违背父类声明要实现的功能

      > 父类中提供的 sortOrdersByAmount()按金额排序，子类重写后按照了创建时间排序。

  2. 子类违背父类对输入、输出、异常的约定

     > 1. 父类中某个函数约定：运行出错的时候返回 null；而子类运行出错抛出异常。
     > 2. 父类中某个函数约定，输入数据可以是任意整数，而子类只能输入正整数。
     > 3. 父类规定了异常类型，子类重载后不能抛出规定外的异常类型。

  3. 子类违背父类注释中所罗列的任何特殊说明

     > 父类中提现函数的注释：“用户的提现金额不得超过账户余额……”，而子类重写后，实现了透支的功能。

## 接口隔离「I」

> 接口的调用者不应该被强迫依赖不需要的接口。

- **理解**

  1. 一组接口集合、微服务接口

      > 如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
      > 它可以是某个微服务的接口，也可以是某个类库的接口等等。
      
  1. 单个API接口或函数

      > 函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。
      > 部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
      
  1. 接口设计

      > 接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

- **和单一职责原则的区别**

  > 单一职责原则针对的是模块、类、接口的设计。
  > 接口隔离原则针对的是接口。
  >
  > 在思考角度上，接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

## 依赖反转原则「D」

> 高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。
>
> - laravel的接口绑定具体的类，就实现了高底层都依赖抽象。

- **控制反转「IOC」**

  > 一个笼统的设计思想，指导框架层面的设计。

  - 控制

      > 指的是对程序执行流程的控制。

  - 反转

      > 指的是在没有使用框架之前，程序员自己控制整个程序的执行。
      > 在使用框架之后，整个程序的执行流程可以通过框架来控制。
      > 流程的控制权从程序员“反转”到了框架。

      - 个人概括：增加自动化，让程序员对代码的控制方式尽可能简单。
      - 较好解读：控制反转就是有架构控制了整个流程，开发者只要在预留的拓展点上做开发就好了。


- **依赖注入「DI」**

  > 具体的编码技巧
  >
  > 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

- **依赖注入框架**

  > 我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。
  >
  > 也可以叫控制反转容器。

  - 个人理解：更抽象一层，将类之间的关系、类的实例化、生命周期由框架本身实现，不需要人工干预，只需要配置一下就好。laravel的服务绑定非常典型。

## 其他原则

- **KISS原则**

  > 讲怎么做：尽量保持简单。
  >
  > - KISS 原则是保持代码可读和可维护的重要手段。
  > - 代码行数越少并不代表代码越简单，
  > - 我们还要考虑逻辑复杂度、实现难度、代码的可读性等。
  > - 本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。
  > - 同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。

  - *如何写出kiss原则的代码*

    > - 不要使用同事可能不懂的技术来实现代码。
    > - 不要重复造轮子，要善于使用已经有的工具类库。
    > - 不要过度优化。

- **YAGNI**

  > 讲怎么做：不要去设计当前用不到的功能；不要去编写当前用不到的代码。
  >
  > - 我们先预留好扩展点，等到需要的时候，再去实现这部分代码。
  > - 不要在项目中提前引入不需要依赖的开发包。

- **DRY**

  > 不要写重复的代码。

  - *代码重复情况*

    > - 实现逻辑重复：实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
    >
    > - 功能语义重复：实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。
    >
    > - 代码执行重复：代码执行重复也算是违反 DRY 原则。

  - *代码执行重复*

    > - 减少代码耦合
    > - 满足单一职责原则
    > - 模块化
    > - 业务与非业务逻辑分离
    > - 通用代码下沉
    > - 继承、多态、抽象、封装
    > - 应用模板等设计模式

- **迪米特法则**

  > 不该有直接依赖关系的类之间，不要有依赖；
  > 有依赖关系的类之间，尽量只依赖必要的接口。（也就是定义中的“有限知识”）。

  - **高内聚**
      
      > - 指导类本身的设计。
      > - 相近的功能放到同一个类中，修改会比较几种，代码容易维护。
      > - 单一职责原则。

  - **松耦合**
      
      > - 指导类与类的依赖关系。
      > - 类与类的依赖关系简单清晰。一个类的修改很少影响到另一个类的。
      > - 依赖注入、接口隔离、基于接口而非实现编程。

# 设计模式

## 创建型

### 单例模式

> 一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类。

- **应用场景**

  > 有些数据在系统中只应该保存一份，就比较适合设计为单例类。
  >
  > - 配置文件

- **存在的问题**

  > - 单例对 OOP 特性的支持不友好。
  > - 单例会隐藏类之间的依赖关系。
  > - 单例对代码的扩展性不友好。
  > - 单例对代码的可测试性不友好。
  > - 单例不支持有参数的构造函数。

- **实现**

  > 饿汉式
  >
  > 懒汉式

- **作用范围**

  - *集群唯一*

    > 获取对象时，要从文件中获取，并加锁。
    > 释放时，将对象放回文件，并显示释放锁。

  - *进程唯一*

    > 经典单例模式

  - *线程唯一*

    > instance用数组实现，不同的线程id对应一个对象。其实也叫多例


### 工厂模式

> 让工厂类来创建不同的对象。

- **使用场景**

  1. 代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。

  2. 不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。

  > - 在第一种情况下，当对象创建比较简单时，用**简单工厂**模式。
  >
  > - 在第一种情况下，当对象创建比较复杂时，用**工厂方法**模式。
  >
  > - 第二种情况，应该把对象的创建由工厂实现，用**工厂方法**模式。
  >
  > - 当要创建的对象有两种分类方式时
  >   - 不需要每个对象实现一个工厂类。
  >     - 让一个工厂负责创建多个不同类型的对象。
  >     - 其实就是一种类型通过继承实现，一种类型通过接口实现。

- **三种工厂模式的区别**

  > 类型A：a，b；
  > 类型B：c，d；
  > 类型C：a，c；
  > 类型D：b，d；

  - **简单工厂**：实现一个工厂类，工厂类中有1个创建方法，通过参数和if-else或者反射来分别创建不同的对象。

  - **工厂方法**：实现4个工厂类，每个工厂类实现创建每个对象。这样if-else又到了调用层，建议再用一个创建工厂的工厂类用简单工厂方式来实现，或者在外部用反射。

  - **抽象工厂**：实现两个工厂类，每个工厂类实现通过不同函数或者if-else实现两种对象。其中一种分类按照继承关联，另一种按照接口类关联。


- **作用**

  > - 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
  > - 代码复用：创建代码抽离到独立的工厂类之后可以复用。
  > - 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
  > - 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

### 建造者模式

> 让建造者类来负责对象的创建工作。

- **使用场景**

  > 当构造参数列表过长时，影响可读性时。一般会考虑用set方法来动态设置属性。

  - 参数很长，又必填，如果用set没法校验是否必填。
  - 如果类的属性之间有一定的依赖关系或者约束条件。
  - 希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。

### 原型模式

> 利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。

- **深拷贝**

  > 深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。

- **浅拷贝**

  > 只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象。

## 结构型

### 代理模式

> 在不改变原始类（或叫被代理类）的情况下，通过引入代理类来给原始类附加功能。

- **简单代理方式**

  > - 一般情况下，我们让代理类和原始类实现同样的接口。
  > - 但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

- **动态代理**

  > 1. 向ioc容器一样，在实例化具体类是，真正实例代理类。将真正的实例依赖注入到代理类中。
  > 2. 通过代理类的魔术方法__call和call_user_func_array()实现代理功能。

- **应用场景**

  - 业务系统中开发一些非功能性需求。
  - 监控、统计、鉴权、限流、事务、幂等、日志。

### 桥接模式

> 一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。

- **应用场景**

  > 配合工厂模式，使用更佳。

  - *发送告警*

    > - 渠道：微信、钉钉、邮件、日志
    > - 等级：严重、普通、警告、紧急

### 装饰器模式

> - 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
> - 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。

可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。

### 门面模式「外观模式」

> 迪米特法则（最少知识原则）和接口隔离原则。
>
> 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

- **应用场景**

  1. *解决易用性问题*

     > 门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。
     > 1. Linux 系统调用函数。
     > 2. Linux 的 Shell 命令。

  2. *解决性能问题*

      > 通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。
      > 1. 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。
      > 2. 如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。
      > 3. 如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。
  3. *解决分布式事务问题*

      > 利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。

### 组合模式

> 将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。

- **应用场景**

  > 树状结构

### 享元模式

> 享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
>
> 不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

- **实现**

  > 通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。

## 行为型

### 观察者模式

> 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

- **应用场景**

  > 1. 小到代码层面的解耦，大到架构层面的系统解耦
  > 2. 邮件订阅、RSS Feeds。

- **实现**

  > 1. 同步阻塞
  > 2. 异步非阻塞
  > 3. 进程内
  > 4. 跨进程

### 模板模式

> 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

- **解决的问题**

  - *复用*

    > 所有的子类可以复用父类中提供的模板方法的代码。

  - *扩展*

    > 框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

### 策略模式

> 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。

- **作用**

  > 解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。

- **创建**

  > 由工厂类来完成，封装策略创建的细节。

- **使用**

  > 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：   编译时静态确定和运行时动态确定。其中，「运行时动态确定」才是策略模式最典型的应用场景。

### 职责链模式

> 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

- **应用场景**

  > - 请求过滤。
  > - 字符过滤。

### 状态模式

### 迭代器模式

> 用来遍历集合对象。

- **设计思路**

  > 1. 迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。
  > 2. 待遍历的容器对象通过依赖注入传递到迭代器类中。
  > 3. 容器通过 iterator() 方法来创建迭代器。

- **优势**

  > 1. 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。
  > 2. 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。
  > 3. 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。

### 访问者模式

> 允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。
>
> 双分派的语言不需要访问者模式。

- **双分派**

  > - Single Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。
  > - Double Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。

- **个人理解**

  > 访问者模式和状态模式的区别是：
  > - 状态模式是按状态分类，把每个状态的操作放到一个对象中，适用于操作不膨胀，状态膨胀的场景。
  > - 访问者模式是按照操作分类，每个操作里包含不同状态的相同实现方式，适用于状态不膨胀，操作膨胀的场景。
  > - 如果两个都膨胀，应该考虑使用组合模式。

### 备忘录模式

> 在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

- **应用场景**

  > 防丢失、撤销、恢复等。

- **角色**

  > - *Originator*：发起者，负责创建一个备忘录，并且可以记录、恢复自身的内部状态。
  > - *Memento*：备忘录。用于存储Originator的状态。
  > - *Caretaker*：备忘录管理者，负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。

### 命令模式

### 解释器模式

> 解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。
>
> 用来实现根据语法规则解读「句子」的解释器。

- **模板**

  > 将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

- **应用场景**

  > 根据运算表达式返回数据

### 中介模式

> 中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。

- **应用场景**

> 微服务的注册中心或者网关。